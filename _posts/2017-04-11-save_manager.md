---
layout: post
title: 操作系统之存储器管理（一）
date: 2017-04-11
catalog: true
tag:
    - 基础
---
大学其间没有好好学习，所以回过头来学学计算机的核心课程是非常有必要的今天总结一下操作系统的存储器管理，存储器是一种宝贵而紧俏的资源，对存储器加以有效管理，不仅直接影响存储器的利用率还会影响系统性能，存储器的主要<font color=red>管理对像是</font>内存，为什么呢外存的管理方式与内存相似，只是用途不一样外存主要是用来放文件的，所以外存的管理一般放在文件管理中介绍要说存储器管理首先肯定得说一下存储器的层次结构也就是长什么样子，为什么这样设计存储器了，设计存储器是我们必须要考虑，经济，速度，大小这三个因素，但是呢一般是速度越快就越贵，所以我们只能把他做的小点了，所以才有了存储器的层次结构，一般分为三级CPU寄存器，中间为主存，最底层为辅存，较高档的计算机分为了<font color=red>CPU寄存器，高速缓冲， 主存储器，磁盘缓冲，固定磁盘，可移动存储介质</font>6层，磁盘缓冲之前的属于存储管理器管理的范畴，掉点后他们不再存在，后面的属于设备管理的范畴了。这里不做介绍，寄存器与主存又叫可执行存储器，计算机所采用的访问机制与辅存是不同的，所需时间也不同，进程可以很少的时钟周期对期进行访问，而辅存需要通过I/O设备来实现（涉及中断，设备驱动程序以及物理设备的运行），所以一般能差3个数量级甚至更多，总结一下：不同层次的存储介质，由操作系统统一管理。操作系统的存储器管理负责对可执行存储器的管理也就是寄存器与磁盘缓冲等的管理，（<font color=red>分配，回收及提供存储层次间数据移动等</font>）在设备管理和文件管理中根据用户需求对辅存的管理了<!--more-->
我们对存储器管理的几种介质进行简单的介绍一下：
<font color=red>主存储器</font>（内存或主存），保存进程运行时的程序和数据，也称可执行存储器，CPU的控制部件只能从主存储器中取得指令和数据，数据也能够从主存器读取并装入到寄存器中（反之也一样）CPU对外围设备的管理也依托主存，由于主存慢，引入了寄存器与高速缓冲<font color=red>寄存器</font>速度与CPU差不多，一般用于存放操作数或地址寄存器放便地址转换<font color=red>高速缓冲</font>根据程序的局部性预先放了一些程序到他里面这样可以加快速度，由于价格贵有的设置了多级缓冲，第一级当然容量小一点咯<font color=red>磁盘缓冲</font>利用主存的存储空间来暂存磁盘中读取的信息，本质上是主存
### 程序的装入和链接
要使程序运行就要为其创建进程，要创建进程当然要程序和数据了，内存中用的数据肯定不是和我们自己写的那些源程序，所以就涉及到转换问题了，将源程序变成内存中可执行的程序要经过编译程序编译产生若干目标程序，目标程序链接，形成装入模板最后装入内存，这里还是要说一下，目标程序也可以算一个小的装入程序（本质上可以运行的，我们先让他跑起来也可以），内存肯定是一个字一字按流的形式装入了，所以我们可以一边装入（第一个模块），一边链接，内存感觉还是一个最终的结果，同理CPU也可以边运行程序，内存也一边链接装入（毕竟第一个目录模块也可以算上装入模块了，这个可以理解成时间点上的不同，链接好一点装入一点运行一点）
1. 程序的装入方式<绝对装入方式>，提前程序员知道内存地址，装入时直接放到指定地址就可以了，这种情况肯定是单道程序环境
2. 程序的装入方式<可重定位装入方式或静态重定位>多道程序环境中，编译程序不知道目标模块要放到哪里去，所有的目标模块是从0开始的（逻辑地址）在装入时一次性经过地址转换（指令地址和数据地址）以后不会变。
3. 程序的装入方式<动态运行时装入方式>为了解决程序中的数据不可能永远不变有可能程序在运行时要移动变量等，所以我们在装入模块之后不把他换成实际地址还是逻辑地址，当运行用的着的时候再给实际地址，这样就相当于移动了

===============================

1. 程序链接<静态链接方式>: 经过把目标模板弄成一个完整的装入模块，以后不能再拆开了，静态链接要做两件事第一：相对地址进行修改（原来是几个模块我们可以理解成把他弄成一个大的模块，以前的各个模块分别从0，开始，我们这一次要以大的为0开始，）第二：变换调用符号，这个可以理解为我们要调用原来的C模块，可是我们现在是一个整体了不从在c模块了所以我们就把他变成调用这个时候的地址
2. 程序链接<装入时动态链接>：装入时边链接边装入的方式，优点：方便修改和更新，假如我们在运行时修改了某个模块那么得重新打包装入而这种方法不必要了，第二方便共享，静态链接是拷贝组装，这个是链接
3. 程序链接<运行时动态链接>: 程序运行时才进行链接，这也太狠了吧，运行时每次目标模块有可能不同好比if语句一样，所以我们把所有的目标模块装入内存，需要哪个就链接到这个上面去，不是更好

### 连续分配方式
上面其实是一个存储器管理的铺垫，我们只知道程序怎么运行过能对存储器进行管理了，所以我们先来说存储器的分配问题，他可以分为连续分配和不连续分配，连续分配也可以更加细的分下去，比如单一连续分配还是固定分区（不等的和等的）的连续分配，还是不固定的也就是动态的等等，我们一步一步的来
#### 单一连续分配
适合单任务操作系统分为系统区和用户区，前期加保护机制了，现在不怎么加了，因为即使破坏也是用户自己破坏，破坏了也是影响自己的
#### 固定分区分配
最简单的运行多道程序的管理方式，每个分区一道作业，当有空闲分区，便从外存的后备队列中往内存加入一道作业。
1. **划分分区的方法** （1）分区大小相等，适合用内存空间基本一样的情形，比如温群控系统，缺点就是不灵活，有可能出现大程序无法运行的情况（2）分区大小不等，多个较小的分区，适量的中等分区，少量大分区。
2. **内存分配** 已经划分好空间了就涉及到分配的问题了，为什么呢，比如说有一个分区已经分配了那我们再分是不是不合适了，所以我们通常把分区按大小排队，建立一张分区使用表如下图：当程序要装入时由
3. **内存分配程序**找到一个真正满足要求的还没有分配的将之分配给该程序，然后装状态变为已分配如果没有找到就拒绝分配 ![](/images/2017/0411fenqu.png)

#### 动态分区分配
动态分区分配要考虑三个方面，分配中所用到的数据结构（描述空闲分区和已分配分区的情况包括大小等），分区分配算法，分区分配的回收与操作。
1. **数据结构**：先说一下，我感觉可以这样理解最原始时空区是一个整体但是是多道程序（运行之后分出多个分区），分配之后有可能第一个内存先回收了或者第二个等 ，为了管理我们有两种形式第一空闲分区表，用于记录每个分区的情况，表中包括分区序号，分区始址，分区的大小等 ，第二：空闲分区链：在每个空闲分区开始部分设置一些控制分区分配的信息，设置两个指针可将所有的空闲分区连接，设置分区大小等等
2. **分区分配算法**：<font color=red>a.</font> 首次适应算法（First fit）从链首开始顺序查找，直到找到能满足条件的，划分出去，余下的扔保留在空闲链中，如果没有分配失败。这样做的缺点是，底地址的空间一直被化分出去会留下许多难以利用的小空闲分区，每次都从链头开始，增加查找可用空用空闲分区的开销（明知道前面的太小不能用还要从链头开始）
<font color=red>b.</font>循环首次适应算法（next fit）这个不是每次从链头开始查找了而是从上次找到的空闲分区的下一个分区开始查找，直到找到，再划分出来，为实现算法必须要有一个查询指针，如果链尾还没有找到那么回第一个空闲分区来找，这样的缺点是把所有的分区全分的差不多大了，没有太大的分区了，不适合大任务了，但是减少了空闲分区的开销
<font color=red>c.</font>最佳适应算法(best fit)每次把满足要求的最小空闲分区分给作业，避免大材小用，其实只需要把所有分区按照从小到大排序就可了，但是这个也从在和首次适应算法一样的缺点，<font color>这里还得说一下，链接不一定是物理上相邻的</font>
<font color=red>d.</font>最坏适应算法（worst fit）扫描整个链接，找出最大的空闲分区分割出来让他用，这样做不会产生太小的空闲分区<font color=red>上面的4种算法全称为顺序搜索法</font>，一直按顺序扫描
<font color=red>e.</font>快速适应算法（quick fit）分类搜索法，前面也种全是顺序搜索法，是将空闲分区根据容量大小进行分类，每一类具有相同容量的分区弄成一个链接，这样内存里就会有好多空闲分区链表，同时在内存中设一个管理索引表，每一个表项对应一个分区类弄，并记录每一个分区的表头指针，这个算法的好处是保住了大的空闲分区，第二，速度快，也不会产生内存碎片，但是分区归还主存进算法有点复杂，空闲分区分的越细浪费越严重，典型的空间换取时间。
3. **分区分配操作**：
<font color=red>a.</font> 分配内存，这个没有什么好说的就是利用上面的一种算法找到一个空闲分区，然后判断满足的话从链接中切出去，把地址返回给调用者就可以了
<font color=red>b.</font> 回收内存，当进程运行完毕释放内存时系统根据回收首址，从空闲链中找到相应的插入点就可了，现在有4种情况
第一：如果回收区与插入点的前一个空闲分区相邻，那么他们两合并（首地址就是前一个分区的了，容量大小相加），反之如果与后一个空闲分区响铃他们两合并（首地址就是回收区地址了），如果不相邻就不合并，建立新的表项

#### 伙伴系统
固定分区和动态分区都有不足，固定分区限制了活动进程的数目，利用率低，动态分区算法复杂，回收时要全并，所以开销有点大，伙伴系统是对两者的折衷。
#### 可重定位分区分配
上面的连续分区分配很容易产生碎片的，当内存用完了上面进程的碎片总和可以放下另外一个程序的时候，我们引入了可重定位分区分配的方法 他的的方法就是当内存用完的时候我们把所有的程序进行移动“紧凑”，紧凑使得所有程序的地址发生了改变，数据地址也得修改，我们要对程序和数据进行重定位，重定位内存分配其实就是运行时动态装入的实现<font color=red>动太重定位 位的实现</font>我感觉与运行时链接一样的效果，当我们把程序加入内存时仍然是相对地址，当程序真正运行的时候才会转换到真正地址<font color=red>动太重定位算法</font>与动态分区分配算法差不多只是在内存不够用的时候紧凑下就好了
#### 对换
对换设施的引入是为了解决某些被阻塞的进程一直占用着内存的问题严重影响内存利用率和系统的性能，常见的有进程对换，页面对换，分段对换等，来个小插曲通常是把外存分为文件区和对换区的，文件是为了长久驻留，所以我们要做的是提高利用率，而对换操作比较频繁，所以我们要做的就是提高交换速度（换出和换入）而不是利用率，对换空间的管理，首先和前面的连续分配一样学习，也就是数据结构要记录对换区的使用情况，其和内存动态分配一样建立一个链和表的问题，，算法也一样，首次适应算法等，换出操作：当运行一个进程时他创建了另一个进程内存不够用了，把那些优化及低的阻塞进程给调出去如果中间没有错误的话，就回存中的空间，换入操作：系统定时查看所有的进程状态从中找出就绪状态，且换出时间久的那些进程换入进来
