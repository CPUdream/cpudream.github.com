---
layout:       post
title:        "JVM知识点理解"
date:         2018-08-02 12:00:00
catalog:      true
tags:
    - JVM
---

Java的技术体系主要由虚拟机、Java API、Java编程语言以及许多第三方Java框架构成。

学习JVM的原因：在虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性。为了达到给所有硬件提供一致的虚拟平台的目的，牺牲了一些与硬件相关的特性，所以绝大多数情况下，提升硬件无法等比例地提升程序的动作性能和并发能力，甚至可能对程序运作状况完全没有任何改善，这里面有Java虚拟机的原因。更重要的是人为原因：如果开发人员不了解虚拟机的一些技术特性的运行原理，就无法写出适合虚拟机运行和自优化的代码，其实目前商用的高性能Java虚拟机都提供了相当多的优化特性和调节手段,此时，就需要一部分人掌握虚拟机的特性和调节方法。

我们可以把Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK, JDK是支持Java程序开发的最小环境，可以把Java类库中的Java SE API子集和Java虚拟机这两部分统称为JRE

### Java内存区域

虚拟机自动内存管理机制，不需要delete/free代码， Java运行时数据区：如下图
![](/images/2018/jvm_part.png)
1. 程序计数器：是一块很小的内存空间，每个线程都有一个独立的程序计数器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转都需要异类计数器来完成。
2. Java虚拟机栈： 生命周期与线程相同。每个方法在执行的时候都会创建一个栈帧，存放了编译期可知的基本数据类型，如果线程所请求的栈深度大于虚拟机所永许的深度，将抛出StackOverflowErro异常，如果扩展时无法申请到足够的空间OutOfMemoryError异常
3. 本地方法栈： 和Java虚拟机栈是类似的，只不过这个是为本地方法服务
4. Java堆: 是被所有线程共享的一块区域，在虚拟机启动时创建。唯一目的就是存放对象实例，Java堆是垃圾收集管理的主要区域，因此好多时候被称做“GC堆”从内存回收的角度来看，由于现在收集器基本采用分代收集算法，所以Java堆可以细分为：新生代和老年代，还可以在细一点，不管怎么分存放的还是对象实例，只是为了更好的回收内存或者分配内存，Java堆可以物理不连续，逻辑连续
5. 方法区：是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据；好多人把方法区称为永久代，只不过是因为GC分代收集扩展至方法区，或者说使用了永久代来实现了方法区， 尤其是类的卸载，条件相当苛刻，也会抛出OutOfMemoryError
6. 运行时常量池：是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用

### 对象的创建

1. 虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否加载，解析和初始化。如果没有，就执行相应的加载过程
2. 在类加载检查能过后，虚拟机为新成对象分配内存空间，对象所需大小在类加载完成后便可确定，如果Java堆内存是绝对规整的，所有用过的内存都放在一边，空闲的放在一边，中间放着一个指针作为分界点的指示器，如果Java堆中的内存是不规整的，虚拟机就必须维护一个列表，记录上哪些内存是可用的，在分配的时候找一块足够大的空间划分给对象实例，并更新列表上的记录，选择哪种分配方式是由垃圾收集器是否带有压缩整理功能决定的
3. 除了上面如何划分内存空间之外还有一个问题就是分配内存并发的问题，两种解决方法一种是对分配内存空间的动作进行同步处理，保证更新操作的原子性，另一种是把内存分配的动作按照线程划分到不同的空间，即每个线程在Java堆中有一小块内存，称为本地线程缓冲，可以通过文件来配置
4. 内存分配完之后对其进行初始化，接下来要对对象进行必要的设置，例如是哪个类的实例，如何才能找到类的元数据，对象的哈希码，对象的GC分代年龄等信息，
5. 执行构造函数


### 对象的内存布局

对象在内存中存储布局可以分为3块区域：对象头、实例数据和对齐填充
对象头包括用于存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁。对象头的另一部分是类型指针，即对象指向他的类元数据的指针，通过指针确定他是哪个类的实例，如果是数据还要有数据长度，无法通过无数据得到数组的长度
实例数据是对象真正存储的有效信息，也就是字段内容，
对齐填充：可有可无

### 对象的访问定位
Java程序需要通过reference(引用)来操作堆上的具体对象，但是JVM并没有定义何种方式去定位、访问堆中的对象的具体位置，目前主流的是句柄和指针两种，如果是句柄的话堆中会有一个句柄池， 引用存储的是对象的句柄地址，句柄里包含了对象实例数据与类型数据各自的具体地址信息（也就是两个指针）， 如果是直接指针访问，对象头里面肯定还有一个指向数据类型的指针，使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，只会改变实例数据指针，使用直接指针访问的最大好处是速度更快，它节省了一次指针定位的时间开销，积少成多，HotSpot采用的地二种


### OOM溢出

**Java堆溢出**
只要不断的创建对象，并保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象
**虚拟机栈和本地方法栈溢出**
如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常（不段的添加本地变量）
如果虚拟机扩展栈时无法申请到足够的内存空间，则抛出OOM异常（不断的创建线程）
**方法区和运行时常量池溢出**

### 垃圾收集器与内存分配策略

垃圾收集（GC）作用的对象是Java堆和方法区
1. 哪引起内存需要回收
2. 什么时候回收
3. 如何回收


### 判断对象是否已死
#### 引用计数算法
给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；引用失效时减1，实现简单效率高，无法解决循环引用的问题
#### 可达性分析算法
当一个对象到"GC root"没有任何引用链相连时，则证明对象不可用，则证明可进行垃圾回收
在Java语言中，可作为GC ROOTs的对象包括下面几种：
虚拟机栈中的引用对象
方法区中类的静态属性引用的对象
方法区中常量引用的对象

### 引用
强引用(strong reference)
软引用(soft reference): 在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收
弱引用(weak reference)：只要GC工作就会回收掉这一部门对象，无论当前内存是否足够
虚引用（phantom reference）

即使可达性分析算法中不可达的对象，也并非是“非死不可”，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象是不可达的，将会被第一次标记并且进行一个筛选，筛选的条件是否有必要执行finalize()方法，通过是否重写和虚拟机是否执行过来判断（只执行一次）， 如果有必要执行，就把这个对象放在F-Queue队列中，由一个低优先级的单独执行，我们可以在finalize里面去复活对象，比如把this赋值给另一个对象，过一段时间会对即将回收的集合进行二次标记，如果这个时候还没有逃脱真的就被回收了。

### 回收方法区
Java虚拟机规范中不要求虚拟机在方法区实现垃圾收集，在方法区实现垃圾收集的性价比低，方法区是永久代的垃圾回收，回收内容：废弃常量和无用类
1. 废弃常量： 和Java堆中的回收类似，常量池中的其它类，方法字段的符号引用也与此类似
2. 无用类：该类的所有实例都被回收，加载该类的ClassLoader已经被回收，该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问类的方法，只有满足上面三个条件才会进行回收， 也不是一定会被回收还要看JVM参数的配置

### 垃圾收集算法

#### 标记-清除算法
标记清除算法效率不高，另一个空间问题，标记会产生大量不连续内存碎片，如果程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
#### 复制算法
为了解决效率的问题，它将可用内存按容易划分为大小相等的两块，每次只使用其中的一块，当这一块用完了之后，就将还存活着的对象复制到另一块上面，然后再把已使用的内存空间一次清理掉。

现代的商业虚拟机都采用这种收集算法来回收新生代，研究表明新生代中的对象98%是朝生夕死，所以不需要按照1：1进行划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor, 当要回收内存是复制到另一块Survivor里，当Survivor不够用时，需要依赖其它内存进行分配担保，直接进入老年代。
### 标记整理算法
复制算法只适用新生代，老年代因为对象存活率高，所以复制起来效率就低了，标记整理，不是对可回收的对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，
#### 分代收集算法
根据对象存活周期的不同把内存划分为几块。一般是把Java堆分成新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。在新生代中使用复制算法，老年代中没有担保，所以只能用标记清除算法和标记整理算法

### 拉圾收集器

Serial收集器：是单线程的，收集时暂停掉用户线程，高效
parNew收集器：多线程收集
Paraller Scavenge、
Serial Old收集器、Parallel Old收集器是老年代收集器

### 内存分配与回收策略

大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Min GC
大对象在Eden区GC了也放不下的情况下只能放到老年代，虚拟机为每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过一次GC后仍然存活，并且容纳到survivor后，对象年龄+1，当对象增加到一定程度，默认是15就进入老年代中。
如果对象放不进survivor那么把年龄大的放在老年代中

### 类文件结构
各种不同平台的虚拟机与所有平台都统一使用的程序存储格式字节码是构成平台无关性的基石，Java虚拟机可以执行任何语言经过编辑器生成的class字节码，而不是二进制。
Class文件是一组8位字节为基础单位的二进制流， Class文件格式有两种数据类型：无符号数和表。每个class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件。很多文件存储标准中都用魔数来进行身份识别譬如图片格式gif。不通过后缀名是为了安全，接下来就是class文件主版本和次版本。紧接着是常量池放口，常量池可以理解为class文件之中的资源仓库。常量池存放两个常量：字面量和符号引用，字面量和Java中的常量概念一样，符号引用包括下面三种常量：
1. 类和接口的全限定名
2. 字段的名称和描述符
3. 方法的名称和描述符
Class文件不会保存各个方法，字段的最终内存布局信息，因为这些字段，方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用，当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中
接下来是类索引，父类索引 和接口索引，字段表集合，方法集合（访问标志，名称索引，描述符索引，属性表集合）方法代码存放在方法属性表集合里，属性表集合等等

### 虚拟机类加载机制

只有下面5种情况才执行初始化
1. 遇到new, getstatic,putstatic,invokestatic这4条指令，new代码，读取和设置静态字段，以及调用一个类的静态方法，
2. 使用java.lang.reflect包的方法对类进行抬高调用的时候
3. 初始化一个类的时候，如果发现其父类没有进行过初始化
4. 虚拟机启动，用户需要一个要执行的类（main方法）

通过子类来引用父类中定义的静态字段，只会触发父类初始化
通过数组定义引用类，不会触发此类的初始化
final常量在编译时放入了调用类的常量中

虚拟机类加载的过程也就是加载，验证，准备，解析，初始化这5个阶段的过程
加载阶段
1. 通过一个类的全限定名来获取定义此类的二进制字节流（可以来自于网络，war, jar...）
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
验证阶段
1. 验证是为了确保Class文件的字节流包含的信息符合虚拟机的要求，并且不会危害虚拟机的安全
2. 文件格式验证魔数，元数据验证（字段，方法，是否有父类等进行验证），字节码验证（是否会跳到一个不存在的地方）
**准备阶段**
准备阶段是为类变量分配内存并设置类变量初始值的阶段，只有static变量会被初始化（0），而不是实例变量，初始化到方法区，
**解析阶段**
虚拟机装常量池内的符号引用替换为直接引用的过程， 字段解析，方法解析，接口解析
**初始化阶段**
初始化阶段是执行`<cinit>`的过程，是由编译器把赋值动作和静态语句块合并而类的，虚拟机保证了`<cinit>`在子类方法值行之前父类方法的`<cinit>`已经执行

### 类加载器
虚拟机把类加载的这个动作放在了虚拟机外部去实现，以便应用程序自己决定如何去获取所需要的类
每一个类都需要由类本身和类加载器确定类的唯一性包括 equals(), isInstance()
虚拟机角度类讲 只有两种不同的类加载器：启动类加载器（Bootstrap ClassLoader）由C++实现，另一种是Java语言实现在的独立于虚拟机外部，并全部继承自抽象类java.lang.ClassLoader
开发人员角度：启动类加载器（Bootstrap classLoader）负责加载存放在<JAVA_HOME>\lib目录中的，按名字加载了，名字不符合的也不会加载到虚拟机内存中，启动类加载器无法直接引用，扩展类加载器（Extension ClassLoader）负责加载lib/ext目录中的，开发者可以直接使用，应用程序类加载器，一般是程序默认的加载器

我们的应用程序都是在这3个加载器的配合下进行加载的，这三个类之间的这种关系称为类加载器的双亲委派模型
工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求最终都会传到顶层的启动态加载器中，只有当父加载器反馈自己民无法完成这个加载请求时，子加载器才会尝试自己去加载。

### 参考

[《深入理解Java虚拟机》](https://book.douban.com/subject/6522893/)

https://mp.weixin.qq.com/s/wn_7qve6OCD0SpYILvcKtg
